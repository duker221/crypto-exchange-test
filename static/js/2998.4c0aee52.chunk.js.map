{"version":3,"file":"static/js/2998.4c0aee52.chunk.js","mappings":"+HAAA,SAASA,EAAEC,GAAG,IAAIC,EAAEC,EAAEC,EAAE,GAAG,GAAG,iBAAiBH,GAAG,iBAAiBA,EAAEG,GAAGH,OAAO,GAAG,iBAAiBA,EAAE,GAAGI,MAAMC,QAAQL,GAAG,IAAIC,EAAE,EAAEA,EAAED,EAAEM,OAAOL,IAAID,EAAEC,KAAKC,EAAEH,EAAEC,EAAEC,OAAOE,IAAIA,GAAG,KAAKA,GAAGD,QAAQ,IAAID,KAAKD,EAAEA,EAAEC,KAAKE,IAAIA,GAAG,KAAKA,GAAGF,GAAG,OAAOE,CAAC,CAAQ,SAASI,IAAO,IAAI,IAAIP,EAAEC,EAAEC,EAAE,EAAEC,EAAE,GAAGD,EAAEM,UAAUF,SAASN,EAAEQ,UAAUN,QAAQD,EAAEF,EAAEC,MAAMG,IAAIA,GAAG,KAAKA,GAAGF,GAAG,OAAOE,CAAC,C,yCAAC,S,kBCAlWM,EAAOC,QAAUC,EAAQ,MAARA,CAAqBA,EAAQ,M,kBCA9C,MAAMC,EAAeD,EAAQ,OACvBE,EAAcF,EAAQ,OAE5BF,EAAOC,QAAU,SAAUI,GACzB,MAAMC,EAASH,EAAaE,GACtBE,EAAQH,EAAYC,GAE1B,OAAO,SAAUG,EAAWC,GAE1B,OADkC,kBAAdD,EAAyBA,EAAUE,cAAgBF,GAErE,IAAK,YAAa,OAAO,IAAIF,EAAO,KAAM,IAAK,KAAM,IAAKG,GAC1D,IAAK,YAAa,OAAO,IAAIH,EAAO,KAAM,IAAK,KAAM,IAAKG,GAC1D,IAAK,YAAa,OAAO,IAAIH,EAAO,IAAK,IAAK,KAAM,IAAKG,GACzD,IAAK,YAAa,OAAO,IAAIH,EAAO,IAAK,KAAM,KAAM,IAAKG,GAE1D,IAAK,WAAY,OAAO,IAAIH,EAAO,KAAM,IAAK,EAAM,IAAKG,GACzD,IAAK,WAAY,OAAO,IAAIH,EAAO,KAAM,IAAK,EAAM,IAAKG,GACzD,IAAK,WAAY,OAAO,IAAIH,EAAO,IAAK,IAAK,EAAM,IAAKG,GACxD,IAAK,WAAY,OAAO,IAAIH,EAAO,IAAK,KAAM,EAAM,IAAKG,GAEzD,IAAK,WAAY,OAAO,IAAIF,EAAM,KAAM,IAAK,GAAME,GACnD,IAAK,WAAY,OAAO,IAAIF,EAAM,KAAM,IAAK,GAAME,GAEnD,QAAS,MAAM,IAAIE,MAAM,qBAAuBH,GAEpD,CACF,C,wCC1BA,MAAM,UAAEI,GAAcV,EAAQ,OAE9BF,EAAOC,QAAWI,GAAgB,MAAMC,UAAeM,EACrDC,WAAAA,CAAaC,EAAMC,EAAUC,EAAiBC,EAAeR,GAC3DS,MAAMT,GAENU,KAAKC,MAAQN,EACbK,KAAKE,UAAYN,EACjBI,KAAKG,iBAAmBN,EACxBG,KAAKI,eAAiBN,EACtBE,KAAKK,SAAWf,EAEhBU,KAAKM,OAAS,IAAIpB,EAClBc,KAAKM,OAAOC,WAAWZ,EAAMC,GAC7BI,KAAKQ,YAAa,CACpB,CAEAC,UAAAA,CAAYC,EAAOC,EAAUC,GAC3B,IAAIC,EAAQ,KACZ,IACEb,KAAKc,OAAOJ,EAAOC,EACrB,CAAE,MAAOI,GACPF,EAAQE,CACV,CAEAH,EAASC,EACX,CAEAG,MAAAA,CAAQJ,GACN,IAAIC,EAAQ,KACZ,IACEb,KAAKiB,KAAKjB,KAAKkB,SACjB,CAAE,MAAOH,GACPF,EAAQE,CACV,CAEAH,EAASC,EACX,CAEAC,MAAAA,CAAQK,EAAMR,GACZ,IAAKS,EAAOC,SAASF,IAAyB,kBAATA,EAAmB,MAAM,IAAIG,UAAU,qCAC5E,GAAItB,KAAKQ,WAAY,MAAM,IAAIhB,MAAM,yBAKrC,OAJK4B,EAAOC,SAASF,KAAOA,EAAOC,EAAOG,KAAKJ,EAAMR,IAErDX,KAAKM,OAAOkB,OAAOL,GAEZnB,IACT,CAEAkB,MAAAA,CAAQP,GACN,GAAIX,KAAKQ,WAAY,MAAM,IAAIhB,MAAM,yBACrCQ,KAAKQ,YAAa,EAEdR,KAAKG,kBAAkBH,KAAKM,OAAOmB,kBAAkBzB,KAAKG,kBAC9D,IAAIe,EAASlB,KAAKM,OAAOoB,QAAQ1B,KAAKI,eAAiB,GAKvD,YAJiBuB,IAAbhB,IAAwBO,EAASA,EAAOU,SAASjB,IAErDX,KAAK6B,cAEEX,CACT,CAGAW,WAAAA,GAEE,OADA7B,KAAKM,OAAOC,WAAWP,KAAKC,MAAOD,KAAKE,WACjCF,IACT,CAGA8B,MAAAA,GACE,MAAMC,EAAQ,IAAI5C,EAAOa,KAAKC,MAAOD,KAAKE,UAAWF,KAAKG,iBAAkBH,KAAKI,eAAgBJ,KAAKK,UAItG,OAHAL,KAAKM,OAAO0B,KAAKD,EAAMzB,QACvByB,EAAMvB,WAAaR,KAAKQ,WAEjBuB,CACT,E,wCC3EF,MAAM,UAAEtC,GAAcV,EAAQ,OAE9BF,EAAOC,QAAWI,GAAgB,MAAME,UAAcK,EACpDC,WAAAA,CAAaC,EAAMC,EAAUC,EAAiBP,GAC5CS,MAAMT,GAENU,KAAKC,MAAQN,EACbK,KAAKE,UAAYN,EACjBI,KAAKG,iBAAmBN,EACxBG,KAAKK,SAAWf,EAEhBU,KAAKM,OAAS,IAAIpB,EAClBc,KAAKM,OAAOC,WAAWZ,EAAMC,GAC7BI,KAAKQ,YAAa,CACpB,CAEAC,UAAAA,CAAYC,EAAOC,EAAUC,GAC3B,IAAIC,EAAQ,KACZ,IACEb,KAAKc,OAAOJ,EAAOC,EACrB,CAAE,MAAOI,GACPF,EAAQE,CACV,CAEAH,EAASC,EACX,CAEAG,MAAAA,GAAW,CAEXiB,KAAAA,CAAOC,GACLlC,KAAKiB,KAAKjB,KAAK0B,QAAQQ,GACzB,CAEApB,MAAAA,CAAQK,EAAMR,GACZ,IAAKS,EAAOC,SAASF,IAAyB,kBAATA,EAAmB,MAAM,IAAIG,UAAU,qCAC5E,GAAItB,KAAKQ,WAAY,MAAM,IAAIhB,MAAM,0BAKrC,OAJK4B,EAAOC,SAASF,KAAOA,EAAOC,EAAOG,KAAKJ,EAAMR,IAErDX,KAAKM,OAAOkB,OAAOL,GAEZnB,IACT,CAEA0B,OAAAA,CAASS,EAAgBxB,GAClBX,KAAKQ,aACRR,KAAKQ,YAAa,EAClBR,KAAKM,OAAOmB,kBAAkBzB,KAAKG,mBAGrC,IAAIgB,EAAOnB,KAAKM,OAAOoB,QAAQS,GAG/B,YAFiBR,IAAbhB,IAAwBQ,EAAOA,EAAKS,SAASjB,IAE1CQ,CACT,CAEAU,WAAAA,GAEE,OADA7B,KAAKM,OAAOC,WAAWP,KAAKC,MAAOD,KAAKE,WACjCF,IACT,CAEA8B,MAAAA,GACE,MAAMC,EAAQ,IAAI3C,EAAMY,KAAKC,MAAOD,KAAKE,UAAWF,KAAKG,iBAAkBH,KAAKK,UAIhF,OAHAL,KAAKM,OAAO0B,KAAKD,EAAMzB,QACvByB,EAAMvB,WAAaR,KAAKQ,WAEjBuB,CACT,E,gBClEF,MAAMK,EAAwB,CAAC,EAAG,EAAG,MAAO,EAAG,MAAO,WAAY,WAAY,WAAY,MAAO,EAAG,WAAY,EAAG,WAAY,WAAY,MAAO,WAAY,IAAK,EAAG,IAAK,EAAG,WAAY,EAAG,WAAY,EAAG,WAAY,EAAG,IAAK,WAAY,MAAO,WAAY,MAAO,WAAY,MAAO,WAAY,IAAK,WAAY,MAAO,EAAG,WAAY,WAAY,WAAY,WAAY,MAAO,WAAY,WAAY,EAAG,WAAY,YAE9ZtD,EAAQuD,MAAQ,SAAUC,GACxB,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,KAAMA,EAAO,CAEvC,MAAMC,EAAMF,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCG,EAAMH,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCI,EAAMJ,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCK,EAAML,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCM,EAAMN,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCO,EAAMP,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCQ,EAAMR,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCS,EAAMT,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCU,EAAMV,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IACvCW,EAAMX,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAE7C,IAAIY,EAAKF,GAAON,GAAO,EAAIC,IAAQ,IAC/BQ,EAAKF,GAAON,GAAO,EAAID,IAAQ,IACnC,MAAMU,EAASd,EAAE,GAAKY,EAChBG,EAASf,EAAE,GAAKa,EAChBG,EAAShB,EAAE,IAAMY,EACjBK,EAASjB,EAAE,IAAMa,EACjBK,EAAUlB,EAAE,IAAMY,EAClBO,EAAUnB,EAAE,IAAMa,EAClBO,EAAUpB,EAAE,IAAMY,EAClBS,EAAUrB,EAAE,IAAMa,EAClBS,EAAUtB,EAAE,IAAMY,EAClBW,EAAUvB,EAAE,IAAMa,EACxBD,EAAKV,GAAOI,GAAO,EAAIC,IAAQ,IAC/BM,EAAKV,GAAOI,GAAO,EAAID,IAAQ,IAC/B,MAAMkB,EAASxB,EAAE,GAAKY,EAChBa,EAASzB,EAAE,GAAKa,EAChBa,EAAS1B,EAAE,IAAMY,EACjBe,EAAS3B,EAAE,IAAMa,EACjBe,EAAU5B,EAAE,IAAMY,EAClBiB,EAAU7B,EAAE,IAAMa,EAClBiB,EAAU9B,EAAE,IAAMY,EAClBmB,EAAU/B,EAAE,IAAMa,EAClBmB,EAAUhC,EAAE,IAAMY,EAClBqB,EAAUjC,EAAE,IAAMa,EACxBD,EAAKR,GAAOI,GAAO,EAAIC,IAAQ,IAC/BI,EAAKR,GAAOI,GAAO,EAAID,IAAQ,IAC/B,MAAM0B,EAASlC,EAAE,GAAKY,EAChBuB,EAASnC,EAAE,GAAKa,EAChBuB,EAASpC,EAAE,IAAMY,EACjByB,EAASrC,EAAE,IAAMa,EACjByB,EAAUtC,EAAE,IAAMY,EAClB2B,EAAUvC,EAAE,IAAMa,EAClB2B,EAAUxC,EAAE,IAAMY,EAClB6B,EAAUzC,EAAE,IAAMa,EAClB6B,EAAU1C,EAAE,IAAMY,EAClB+B,EAAU3C,EAAE,IAAMa,EACxBD,EAAKN,GAAOI,GAAO,EAAIC,IAAQ,IAC/BE,EAAKN,GAAOI,GAAO,EAAID,IAAQ,IAC/B,MAAMkC,EAAS5C,EAAE,GAAKY,EAChBiC,EAAS7C,EAAE,GAAKa,EAChBiC,EAAS9C,EAAE,IAAMY,EACjBmC,EAAS/C,EAAE,IAAMa,EACjBmC,EAAUhD,EAAE,IAAMY,EAClBqC,EAAUjD,EAAE,IAAMa,EAClBqC,EAAUlD,EAAE,IAAMY,EAClBuC,EAAUnD,EAAE,IAAMa,EAClBuC,EAAUpD,EAAE,IAAMY,EAClByC,GAAUrD,EAAE,IAAMa,EACxBD,EAAKJ,GAAON,GAAO,EAAIC,IAAQ,IAC/BU,EAAKJ,GAAON,GAAO,EAAID,IAAQ,IAC/B,MAAMoD,GAAStD,EAAE,GAAKY,EAChB2C,GAASvD,EAAE,GAAKa,EAChB2C,GAASxD,EAAE,IAAMY,EACjB6C,GAASzD,EAAE,IAAMa,EACjB6C,GAAU1D,EAAE,IAAMY,EAClB+C,GAAU3D,EAAE,IAAMa,EAClB+C,GAAU5D,EAAE,IAAMY,EAClBiD,GAAU7D,EAAE,IAAMa,EAClBiD,GAAU9D,EAAE,IAAMY,EAClBmD,GAAU/D,EAAE,IAAMa,EAGlBmD,GAASlD,EACTmD,GAASlD,EACTmD,GAAWjD,GAAU,EAAID,IAAW,GACpCmD,GAAWnD,GAAU,EAAIC,IAAW,GACpCmD,GAAUlD,GAAW,EAAIC,IAAY,GACrCkD,GAAUlD,GAAW,EAAID,IAAY,GACrCoD,GAAWjD,GAAW,EAAID,IAAY,GACtCmD,GAAWnD,GAAW,EAAIC,IAAY,GACtCmD,GAAWlD,GAAW,GAAKC,IAAY,GACvCkD,GAAWlD,GAAW,GAAKD,IAAY,GACvCoD,GAAWlD,GAAU,EAAIC,IAAW,GACpCkD,GAAWlD,GAAU,EAAID,IAAW,GACpCoD,GAAUjD,GAAU,GAAKD,IAAW,GACpCmD,GAAUnD,GAAU,GAAKC,IAAW,GACpCmD,GAAWlD,GAAW,GAAKC,IAAY,GACvCkD,GAAWlD,GAAW,GAAKD,IAAY,GACvCoD,GAAUjD,GAAW,GAAKD,IAAY,GACtCmD,GAAUnD,GAAW,GAAKC,IAAY,GACtCmD,GAAWlD,GAAW,EAAIC,IAAY,GACtCkD,GAAWlD,GAAW,EAAID,IAAY,GACtCoD,GAAWjD,GAAU,GAAKD,IAAW,EACrCmD,GAAWnD,GAAU,GAAKC,IAAW,EACrCmD,GAAWlD,GAAU,EAAIC,IAAW,GACpCkD,GAAWlD,GAAU,EAAID,IAAW,GACpCoD,GAAUjD,GAAW,GAAKD,IAAY,GACtCmD,GAAUnD,GAAW,GAAKC,IAAY,GACtCmD,GAAWlD,GAAW,GAAKC,IAAY,GACvCkD,GAAWlD,GAAW,GAAKD,IAAY,GACvCoD,GAAUjD,GAAW,GAAKD,IAAY,EACtCmD,GAAUnD,GAAW,GAAKC,IAAY,EACtCmD,GAAUlD,GAAU,GAAKC,IAAW,EACpCkD,GAAUlD,GAAU,GAAKD,IAAW,EACpCoD,GAAWjD,GAAU,GAAKD,IAAW,EACrCmD,GAAWnD,GAAU,GAAKC,IAAW,EACrCmD,GAAWlD,GAAW,GAAKC,IAAY,EACvCkD,GAAWlD,GAAW,GAAKD,IAAY,EACvCoD,GAAUlD,GAAW,GAAKC,IAAY,GACtCkD,GAAUlD,GAAW,GAAKD,IAAY,GACtCoD,GAAWjD,IAAW,GAAKD,IAAY,EACvCmD,GAAWnD,GAAW,GAAKC,KAAY,EACvCmD,GAAWlD,IAAU,GAAKC,KAAW,EACrCkD,GAAWlD,IAAU,GAAKD,KAAW,EACrCoD,GAAUlD,IAAU,GAAKC,KAAW,GACpCkD,GAAUlD,IAAU,GAAKD,KAAW,GACpCoD,GAAWjD,IAAW,EAAID,KAAY,GACtCmD,GAAWnD,IAAW,EAAIC,KAAY,GACtCmD,GAAWlD,IAAW,EAAIC,KAAY,GACtCkD,GAAWlD,IAAW,EAAID,KAAY,GACtCoD,GAAUlD,IAAW,GAAKC,KAAY,GACtCkD,GAAUlD,IAAW,GAAKD,KAAY,GAG5C9D,EAAE,GAAKgE,IAAWY,GAASY,GAC3BxF,EAAE,GAAKiE,IAAWY,GAASY,GAC3BzF,EAAE,IAAM8F,IAAWY,GAAStC,GAC5BpE,EAAE,IAAM+F,IAAWY,GAAStC,GAC5BrE,EAAE,IAAM0E,IAAYY,GAAUY,GAC9BlG,EAAE,IAAM2E,IAAYY,GAAUY,GAC9BnG,EAAE,IAAMwG,IAAYtC,GAAUY,GAC9B9E,EAAE,IAAMyG,IAAYtC,GAAUY,GAC9B/E,EAAE,IAAMoF,IAAYY,GAAUY,GAC9B5G,EAAE,IAAMqF,IAAYY,GAAUY,GAC9B7G,EAAE,GAAK4E,IAAWY,GAASY,GAC3BpG,EAAE,GAAK6E,IAAWY,GAASY,GAC3BrG,EAAE,IAAM0G,IAAWtC,GAASY,GAC5BhF,EAAE,IAAM2G,IAAWtC,GAASY,GAC5BjF,EAAE,IAAMsF,IAAYY,GAAUY,GAC9B9G,EAAE,IAAMuF,IAAYY,GAAUY,GAC9B/G,EAAE,IAAMkE,IAAYY,GAAUY,GAC9B1F,EAAE,IAAMmE,IAAYY,GAAUY,GAC9B3F,EAAE,IAAMgG,IAAYY,GAAUtC,GAC9BtE,EAAE,IAAMiG,IAAYY,GAAUtC,GAC9BvE,EAAE,GAAKwF,IAAWY,GAASY,GAC3BhH,EAAE,GAAKyF,IAAWY,GAASY,GAC3BjH,EAAE,IAAMoE,IAAWY,GAASY,GAC5B5F,EAAE,IAAMqE,IAAWY,GAASY,GAC5B7F,EAAE,IAAMkG,IAAYY,GAAUtC,GAC9BxE,EAAE,IAAMmG,IAAYY,GAAUtC,GAC9BzE,EAAE,IAAM8E,IAAYY,GAAUY,GAC9BtG,EAAE,IAAM+E,IAAYY,GAAUY,GAC9BvG,EAAE,IAAM4G,IAAYtC,GAAUY,GAC9BlF,EAAE,IAAM6G,IAAYtC,GAAUY,GAC9BnF,EAAE,GAAKoG,IAAWY,GAAShD,GAC3BhE,EAAE,GAAKqG,IAAWY,GAAShD,GAC3BjE,EAAE,IAAMgF,IAAWY,GAASE,GAC5B9F,EAAE,IAAMiF,IAAWY,GAASE,GAC5B/F,EAAE,IAAM8G,IAAYtC,GAAUE,GAC9B1E,EAAE,IAAM+G,IAAYtC,GAAUE,GAC9B3E,EAAE,IAAM0F,IAAYY,GAAUE,GAC9BxG,EAAE,IAAM2F,IAAYY,GAAUE,GAC9BzG,EAAE,IAAMsE,IAAYY,GAAUE,GAC9BpF,EAAE,IAAMuE,IAAYY,GAAUE,GAC9BrF,EAAE,GAAKgH,IAAWhD,GAASY,GAC3B5E,EAAE,GAAKiH,IAAWhD,GAASY,GAC3B7E,EAAE,IAAM4F,IAAWE,GAASY,GAC5B1G,EAAE,IAAM6F,IAAWE,GAASY,GAC5B3G,EAAE,IAAMwE,IAAYE,GAAUY,GAC9BtF,EAAE,IAAMyE,IAAYE,GAAUY,GAC9BvF,EAAE,IAAMsG,IAAYE,GAAUtC,GAC9BlE,EAAE,IAAMuG,IAAYE,GAAUtC,GAC9BnE,EAAE,IAAMkF,IAAYE,GAAUY,GAC9BhG,EAAE,IAAMmF,IAAYE,GAAUY,GAG9BjG,EAAE,IAAMF,EAA8B,EAARG,GAC9BD,EAAE,IAAMF,EAA8B,EAARG,EAAY,EAC5C,CACF,C,uCCzLA,MAAMiH,EAAczK,EAAQ,OAE5B,SAASI,IAEPa,KAAKyJ,MAAQ,CACX,EAAG,EAAG,EAAG,EAAG,EACZ,EAAG,EAAG,EAAG,EAAG,EACZ,EAAG,EAAG,EAAG,EAAG,EACZ,EAAG,EAAG,EAAG,EAAG,EACZ,EAAG,EAAG,EAAG,EAAG,GAGdzJ,KAAK0J,UAAY,KACjB1J,KAAK2J,MAAQ,EACb3J,KAAK4J,WAAY,CACnB,CAEAzK,EAAO0K,UAAUtJ,WAAa,SAAUZ,EAAMC,GAC5C,IAAK,IAAIkK,EAAI,EAAGA,EAAI,KAAMA,EAAG9J,KAAKyJ,MAAMK,GAAK,EAC7C9J,KAAK0J,UAAY/J,EAAO,EACxBK,KAAK2J,MAAQ,EACb3J,KAAK4J,WAAY,CACnB,EAEAzK,EAAO0K,UAAUrI,OAAS,SAAUL,GAClC,IAAK,IAAI2I,EAAI,EAAGA,EAAI3I,EAAKzC,SAAUoL,EACjC9J,KAAKyJ,SAASzJ,KAAK2J,MAAQ,KAAOxI,EAAK2I,IAAY9J,KAAK2J,MAAQ,EAAlB,EAC9C3J,KAAK2J,OAAS,EACV3J,KAAK2J,QAAU3J,KAAK0J,YACtBF,EAAYnH,MAAMrC,KAAKyJ,OACvBzJ,KAAK2J,MAAQ,EAGnB,EAEAxK,EAAO0K,UAAUpI,kBAAoB,SAAUsI,GAC7C/J,KAAKyJ,SAASzJ,KAAK2J,MAAQ,KAAOI,GAAc/J,KAAK2J,MAAQ,EAAlB,EACrB,KAAV,IAAPI,IAAsB/J,KAAK2J,QAAW3J,KAAK0J,UAAY,GAAIF,EAAYnH,MAAMrC,KAAKyJ,OACvFzJ,KAAKyJ,UAAUzJ,KAAK0J,UAAY,GAAK,KAAO,MAAe1J,KAAK0J,UAAY,GAAK,EAA5B,EACrDF,EAAYnH,MAAMrC,KAAKyJ,OACvBzJ,KAAK2J,MAAQ,EACb3J,KAAK4J,WAAY,CACnB,EAEAzK,EAAO0K,UAAUnI,QAAU,SAAUhD,GAC9BsB,KAAK4J,WAAW5J,KAAKyB,kBAAkB,GAE5C,MAAMuI,EAAS5I,EAAO6I,MAAMvL,GAC5B,IAAK,IAAIoL,EAAI,EAAGA,EAAIpL,IAAUoL,EAC5BE,EAAOF,GAAM9J,KAAKyJ,SAASzJ,KAAK2J,MAAQ,MAAc3J,KAAK2J,MAAQ,EAAlB,EAAyB,IAC1E3J,KAAK2J,OAAS,EACV3J,KAAK2J,QAAU3J,KAAK0J,YACtBF,EAAYnH,MAAMrC,KAAKyJ,OACvBzJ,KAAK2J,MAAQ,GAIjB,OAAOK,CACT,EAEA7K,EAAO0K,UAAU7H,KAAO,SAAUkI,GAChC,IAAK,IAAIJ,EAAI,EAAGA,EAAI,KAAMA,EAAGI,EAAKT,MAAMK,GAAK9J,KAAKyJ,MAAMK,GACxDI,EAAKR,UAAY1J,KAAK0J,UACtBQ,EAAKP,MAAQ3J,KAAK2J,MAClBO,EAAKN,UAAY5J,KAAK4J,SACxB,EAEA/K,EAAOC,QAAUK,C,kPClEJ,IC0BAZ,EChBP4L,ECRFC,EAgGS/L,EC+ETyL,EAWAO,EAEElM,EA0BAG,EC/LFF,EAmJEkM,EACAhI,EC5KKiI,ENUEC,EAAgC,CAAC,EACjCC,EAAY,GACZC,EACZ,oECbYC,EAAUnM,MAAMC,QAStB,SAASmM,EAAOrM,EAAK4L,GAE3B,IAAK,IAAIC,KAAKD,EAAO5L,EAAI6L,GAAKD,EAAMC,GACpC,OAA6B7L,CAC9B,CAQgB,SAAAsM,EAAWtM,GACtBA,GAAQA,EAAKuM,YAAYvM,EAAKuM,WAAWC,YAAYxM,EAC1D,CEXO,SAASyM,EAAcb,EAAMC,EAAO/L,GAC1C,IACCyL,EACAO,EACAlM,EAHGG,EAAkB,CAAC,EAIvB,IAAKH,KAAKiM,EACA,OAALjM,EAAY2L,EAAMM,EAAMjM,GACd,OAALA,EAAYkM,EAAMD,EAAMjM,GAC5BG,EAAgBH,GAAKiM,EAAMjM,GAUjC,GAPIS,UAAUF,OAAS,IACtBJ,EAAgB2M,SACfrM,UAAUF,OAAS,EAAIH,EAAM2M,KAAKtM,UAAW,GAAKP,GAKjC,mBAAR8L,GAA2C,MAArBA,EAAKgB,aACrC,IAAKhN,KAAKgM,EAAKgB,kBAAA,IACV7M,EAAgBH,KACnBG,EAAgBH,GAAKgM,EAAKgB,aAAahN,IAK1C,OAAOiN,EAAYjB,EAAM7L,EAAiBwL,EAAKO,EAAK,KACrD,CAcO,SAASe,EAAY7M,EAAMF,EAAOyL,EAAKO,EAAKlM,GAIlD,IAAMG,EAAQ,CACb+M,KAAA9M,EACA+M,MAAAjN,EACAkN,IAAAzB,EACA0B,IAAAnB,EACAoB,IAAW,KACXC,GAAS,KACTC,IAAQ,EACRC,IAAM,KAKNC,SAAA,EACAC,IAAY,KACZpM,iBAAA,EACAqM,IAAuB,MAAZ5N,IAAqBiM,EAAUjM,EAC1C6N,KAAS,EACTC,IAAQ,GAMT,OAFgB,MAAZ9N,GAAqC,MAAjBgM,EAAQ+B,OAAe/B,EAAQ+B,MAAM5N,GAEtDA,CACR,CAEO,SAAS6N,IACf,MAAO,CAAEC,QAAS,KACnB,UAEgBC,EAAS9N,GACxB,OAAOA,EAAM0M,QACd,UC/EgBqB,EAAc/N,EAAO4L,GACpCnK,KAAKsL,MAAQ/M,EACbyB,KAAKuM,QAAUpC,CAChB,CA0EgB,SAAAqC,EAAcjO,EAAO4L,GACpC,GAAkB,MAAdA,EAEH,OAAO5L,EAAKmN,GACTc,EAAcjO,EAAKmN,GAAUnN,EAAKyN,IAAU,GAC5C,KAIJ,IADA,IAAI5B,EACGD,EAAa5L,EAAKkN,IAAW/M,OAAQyL,IAG3C,GAAe,OAFfC,EAAU7L,EAAKkN,IAAWtB,KAEa,MAAhBC,EAAOwB,IAI7B,OAAOxB,EAAOwB,IAShB,MAA4B,mBAAdrN,EAAM8M,KAAqBmB,EAAcjO,GAAS,IACjE,CA2CA,SAASkO,EAAwBlO,GAAjC,IAGW4L,EACJC,EAHN,GAA+B,OAA1B7L,EAAQA,EAAKmN,KAAyC,MAApBnN,EAAKuN,IAAqB,CAEhE,IADAvN,EAAKqN,IAAQrN,EAAKuN,IAAYY,KAAO,KAC5BvC,EAAI,EAAGA,EAAI5L,EAAKkN,IAAW/M,OAAQyL,IAE3C,GAAa,OADTC,EAAQ7L,EAAKkN,IAAWtB,KACO,MAAdC,EAAKwB,IAAe,CACxCrN,EAAKqN,IAAQrN,EAAKuN,IAAYY,KAAOtC,EAAKwB,IAC1C,KACD,CAGD,OAAOa,EAAwBlO,EAChC,CACD,CA4BgB,SAAAoO,EAAcpO,KAE1BA,EAACsN,MACDtN,EAACsN,KAAA,IACF/B,EAAc7I,KAAK1C,KAClBqO,EAAOC,OACTxC,IAAiBF,EAAQ2C,sBAEzBzC,EAAeF,EAAQ2C,oBACN3O,GAAOyO,EAE1B,CASA,SAASA,IAAT,IACKrO,EAME6L,EAzGkB/L,EAOjBgM,EANHlM,EACHC,EACAkM,EACAhI,EAmGD,IAHAwH,EAAciD,KAAKzO,GAGXC,EAAIuL,EAAckD,SACrBzO,EAACsN,MACAzB,EAAoBN,EAAcpL,OAlGjC2L,OAAA,EALNjM,GADGD,GADoBE,EA0GNE,GAzGMwN,KACNH,IACjBtB,EAAc,GACdhI,EAAW,GAERjE,EAAS4O,OACN5C,EAAWO,EAAO,CAAC,EAAGzM,IACpB4N,IAAa5N,EAAQ4N,IAAa,EACtC5B,EAAQ+B,OAAO/B,EAAQ+B,MAAM7B,GAEjC6C,EACC7O,EAAS4O,IACT5C,EACAlM,EACAE,EAAS8O,IACT9O,EAAS4O,IAAYG,aJzII,GI0IzBjP,EAAQ8N,IAAyB,CAAC7N,GAAU,KAC5CkM,EACU,MAAVlM,EAAiBoO,EAAcrO,GAAYC,KJ5IlB,GI6ItBD,EAAQ8N,KACX3J,GAGD+H,EAAQ0B,IAAa5N,EAAQ4N,IAC7B1B,EAAQqB,GAAAD,IAAmBpB,EAAQ2B,KAAW3B,EAC9CgD,EAAW/C,EAAaD,EAAU/H,GAE9B+H,EAAQuB,KAASxN,GACpBqO,EAAwBpC,IA8EpBP,EAAcpL,OAAS0L,GAI1BN,EAAciD,KAAKzO,IAItBsO,EAAOC,IAAkB,CAC1B,CGlNO,SAASS,EACf/O,EACA4L,EACAC,EACA/L,EACAyL,EACAO,EACAlM,EACAG,EACAF,EACAkM,EACAhI,GAXM,IAaFiI,EAEHG,EAEAC,EAEAC,EAEAC,EAKGG,EAAe3M,GAAkBA,EAAcoN,KAAehB,EAE9DW,EAAoBjB,EAAazL,OAMrC,IAJA0L,EAAcyB,IAAYzN,EAC1BmP,EAA0BnD,EAAgBD,EAAca,GACxD5M,EAASgM,EAAcyB,IAElBtB,EAAI,EAAGA,EAAIa,EAAmBb,IAEhB,OADlBI,EAAaP,EAAcqB,IAAWlB,MAMrCG,GAD0B,IAAvBC,EAAUqB,IACFxB,EAEAQ,EAAYL,EAAUqB,MAAYxB,EAI9CG,EAAUqB,IAAUzB,EAGpB2C,EACC3O,EACAoM,EACAD,EACAZ,EACAO,EACAlM,EACAG,EACAF,EACAkM,EACAhI,GAIDsI,EAASD,EAAUiB,IACfjB,EAAWa,KAAOd,EAASc,KAAOb,EAAWa,MAC5Cd,EAASc,KACZgC,EAAS9C,EAASc,IAAK,KAAMb,GAE9BrI,EAASrB,KACR0J,EAAWa,IACXb,EAAUmB,KAAelB,EACzBD,IAImB,MAAjBE,GAAmC,MAAVD,IAC5BC,EAAgBD,GPpGS,MOwGzBD,EAAUsB,KACVvB,EAAQe,MAAed,EAAUc,IAEjCrN,EAASqP,EAAO9C,EAAYvM,EAAQG,GAEV,mBAAnBoM,EAAWU,WAAA,IAClBV,EAAUkB,IAKVzN,EAASuM,EAAUkB,IACTjB,IACVxM,EAASwM,EAAO8C,aAQjB/C,EAAUkB,SAAA,EAGVlB,EAAUsB,MAAW,QAatB7B,EAAcyB,IAAYzN,EAC1BgM,EAAcwB,IAAQf,CACvB,CAOA,SAAS0C,EAA0BhP,EAAgB4L,EAAcC,GAAjE,IAEK/L,EAEAyL,EAEAO,EA+DGlM,EAOAG,EApEDF,EAAoB+L,EAAazL,OACnC4L,EAAoBF,EAAY1L,OACnC4D,EAAuBgI,EAEpBC,EAAO,EAGX,IADAhM,EAAckN,IAAa,GACtBpN,EAAI,EAAGA,EAAID,EAAmBC,IAMnB,OAHfyL,EAAaK,EAAa9L,KAIJ,kBAAdyL,GACc,mBAAdA,GA8CF3L,EAAcE,EAAIkM,GA/BvBT,EAAavL,EAAckN,IAAWpN,GANjB,iBAAdyL,GACc,iBAAdA,GAEc,iBAAdA,GACPA,EAAWpK,aAAeiO,OAEiBvC,EAC1C,KACAtB,EACA,KACA,KACA,MAESa,EAAQb,GACyBsB,EAC1CiB,EACA,CAAEpB,SAAUnB,GACZ,KACA,KACA,eAESA,EAAWpK,aAA6BoK,EAAU6B,IAAU,EAK3BP,EAC1CtB,EAAWuB,KACXvB,EAAWwB,MACXxB,EAAWyB,IACXzB,EAAW0B,IAAM1B,EAAW0B,IAAM,KAClC1B,EAAUiC,KAGgCjC,GAIlC4B,GAAWnN,EACrBuL,EAAU6B,IAAUpN,EAAcoN,IAAU,EAY5CtB,EAAW,MACY,KARjB/L,EAAiBwL,EAAUkC,IAAU4B,EAC1C9D,EACAM,EACAjM,EACAmE,MAMAA,KADA+H,EAAWD,EAAY9L,MAGtB+L,EAAQ4B,KP5OW,SOmPU,MAAZ5B,GAA2C,OAAvBA,EAAQ0B,MAGxB,GAAlBzN,GACHiM,IAI6B,mBAAnBT,EAAWuB,OACrBvB,EAAUmC,KP9Pc,QOgQf3N,IAAkBH,IAiBxBG,GAAiBH,EAAc,EAClCoM,IACUjM,GAAiBH,EAAc,EACzCoM,KAEIjM,EAAgBH,EACnBoM,IAEAA,IAMDT,EAAUmC,KP/Rc,SO+KzBnC,EAAavL,EAAckN,IAAWpN,GAAK,KAyH7C,GAAIiE,EACH,IAAKjE,EAAI,EAAGA,EAAIiM,EAAmBjM,IAElB,OADhBgM,EAAWD,EAAY/L,KACiC,IPzSpC,OOySKgM,EAAQ4B,OAC5B5B,EAAQuB,KAASrN,EAAcsN,MAClCtN,EAAcsN,IAAYW,EAAcnC,IAGzCwD,EAAQxD,EAAUA,GAItB,CAQA,SAASoD,EAAOlP,EAAa4L,EAAQC,GAArC,IAIM/L,EACKyL,EAFV,GAA+B,mBAApBvL,EAAY8M,KAAoB,CAE1C,IADIhN,EAAWE,EAAWkN,IACjB3B,EAAI,EAAGzL,GAAYyL,EAAIzL,EAASK,OAAQoL,IAC5CzL,EAASyL,KAKZzL,EAASyL,GAAE4B,GAAWnN,EACtB4L,EAASsD,EAAOpP,EAASyL,GAAIK,EAAQC,IAIvC,OAAOD,CACR,CAAW5L,EAAWqN,KAASzB,IAC1BA,GAAU5L,EAAY8M,OAASjB,EAAU0D,SAAS3D,KACrDA,EAASqC,EAAcjO,IAExB6L,EAAU2D,aAAaxP,EAAWqN,IAAOzB,GAAU,MACnDA,EAAS5L,EAAWqN,KAGrB,GACCzB,EAASA,GAAUA,EAAOuD,kBACR,MAAVvD,GAAsC,IAApBA,EAAO6D,UAElC,OAAO7D,CACR,CAQgB,SAAA8D,EAAa1P,EAAU4L,GAUtC,OATAA,EAAMA,GAAO,GACG,MAAZ5L,GAAuC,kBAAZA,IACpBoM,EAAQpM,GAClBA,EAAS2P,MAAK,SAAA3P,GACb0P,EAAa1P,EAAO4L,EACrB,IAEAA,EAAIlJ,KAAK1C,IAEH4L,CACR,CASA,SAASyD,EACRrP,EACA4L,EACAC,EACA/L,GAJD,IAMOyL,EAAMvL,EAAWgN,IACjBlB,EAAO9L,EAAW8M,KACpBlN,EAAIiM,EAAc,EAClB9L,EAAI8L,EAAc,EAClBhM,EAAW+L,EAAYC,GAc3B,GACc,OAAbhM,GACCA,GACA0L,GAAO1L,EAASmN,KAChBlB,IAASjM,EAASiN,MACc,IPjZZ,OOiZnBjN,EAAQ6N,KAEV,OAAO7B,EACD,GAXN/L,GACa,MAAZD,GAAoD,IP1YhC,OO0YCA,EAAQ6N,KAA2B,EAAI,GAW7D,KAAO9N,GAAK,GAAKG,EAAI6L,EAAYzL,QAAQ,CACxC,GAAIP,GAAK,EAAG,CAEX,IADAC,EAAW+L,EAAYhM,KAGU,IP1Zd,OO0ZjBC,EAAQ6N,MACTnC,GAAO1L,EAASmN,KAChBlB,IAASjM,EAASiN,KAElB,OAAOlN,EAERA,GACD,CAEA,GAAIG,EAAI6L,EAAYzL,OAAQ,CAE3B,IADAN,EAAW+L,EAAY7L,KAGU,IPvad,OOuajBF,EAAQ6N,MACTnC,GAAO1L,EAASmN,KAChBlB,IAASjM,EAASiN,KAElB,OAAO/M,EAERA,GACD,CACD,CAGD,OAAQ,CACT,CFvbA,SAAS6P,EAAS5P,EAAO4L,EAAKC,GACd,MAAXD,EAAI,GACP5L,EAAM6P,YAAYjE,EAAc,MAATC,EAAgB,GAAKA,GAE5C7L,EAAM4L,GADa,MAATC,EACG,GACa,iBAATA,GAAqBM,EAAmB2D,KAAKlE,GACjDC,EAEAA,EAAQ,IAEvB,CAuBO,SAASkE,EAAY/P,EAAK4L,EAAMC,EAAO/L,EAAUyL,GACvD,IAAIO,EAEJ9L,EAAG,GAAa,UAAT4L,EACN,GAAoB,iBAATC,EACV7L,EAAIgQ,MAAMC,QAAUpE,MACd,CAKN,GAJuB,iBAAZ/L,IACVE,EAAIgQ,MAAMC,QAAUnQ,EAAW,IAG5BA,EACH,IAAK8L,KAAQ9L,EACN+L,GAASD,KAAQC,GACtB+D,EAAS5P,EAAIgQ,MAAOpE,EAAM,IAK7B,GAAIC,EACH,IAAKD,KAAQC,EACP/L,GAAY+L,EAAMD,KAAU9L,EAAS8L,IACzCgE,EAAS5P,EAAIgQ,MAAOpE,EAAMC,EAAMD,GAIpC,MAGQ,GAAY,MAAZA,EAAK,IAA0B,MAAZA,EAAK,GAChCE,EACCF,KAAUA,EAAOA,EAAKsE,QAAQ,8BAA+B,OAQ7DtE,EAJAA,EAAK5K,gBAAiBhB,GACb,eAAT4L,GACS,cAATA,EAEOA,EAAK5K,cAAcmP,MAAM,GACrBvE,EAAKuE,MAAM,GAElBnQ,EAAG4L,IAAa5L,EAAG4L,EAAc,CAAC,GACvC5L,EAAG4L,EAAYA,EAAOE,GAAcD,EAEhCA,EACE/L,EAQJ+L,EAAMA,EAAY/L,EAAS+L,GAP3BA,EAAMA,EAAYhM,EAClBG,EAAIoQ,iBACHxE,EACAE,EAAa/H,EAAoBgI,EACjCD,IAMF9L,EAAIqQ,oBACHzE,EACAE,EAAa/H,EAAoBgI,EACjCD,OAGI,CACN,GAAiB,8BAAbP,EAIHK,EAAOA,EAAKsE,QAAQ,cAAe,KAAKA,QAAQ,SAAU,UACpD,GACE,SAARtE,GACQ,UAARA,GACQ,QAARA,GACQ,QAARA,GACQ,QAARA,GAGQ,YAARA,GACQ,YAARA,GACQ,WAARA,GACQ,WAARA,GACQ,QAARA,GACQ,WAARA,GACAA,KAAQ5L,EAER,IACCA,EAAI4L,GAAiB,MAATC,EAAgB,GAAKA,EAEjC,MAAM7L,CACK,CAAV,MAAOA,GAAG,CAUO,mBAAT6L,IAES,MAATA,IAAA,IAAkBA,GAA+B,MAAZD,EAAK,GAGpD5L,EAAIsQ,gBAAgB1E,GAFpB5L,EAAIuQ,aAAa3E,EAAc,WAARA,GAA8B,GAATC,EAAgB,GAAKA,GAInE,CACD,CAOA,SAAS2E,EAAiBxQ,GAMzB,OAAiB,SAAA6L,GAChB,GAAIpK,KAAImK,EAAa,CACpB,IAAM9L,EAAe2B,KAAImK,EAAYC,EAAEiB,KAAO9M,GAC9C,GAAqB,MAAjB6L,EAAE/L,EACL+L,EAAE/L,EAAcD,SAKN,GAAAgM,EAAE/L,EAAcA,EAAa+L,EACvC,OAED,OAAO/L,EAAa8L,EAAQ6E,MAAQ7E,EAAQ6E,MAAM5E,GAAKA,EACxD,CACD,CACD,CG5IgB,SAAA8C,EACf3O,EACA6L,EACA/L,EACAyL,EACAO,EACAlM,EACAG,EACAF,EACAkM,EACAhI,GAVe,IAaXiI,EAkBEC,EAAGC,EAAOC,EAAUG,EAAUG,EAAUI,EACxCe,EACEK,EAMFC,EACAE,EAyGOC,EA4BPW,EACHE,EASSQ,EA6BNL,EAtMLO,EAAU/D,EAASiB,KAIpB,QAAI,IAAAjB,EAAS1K,YAA2B,OAAW,KR9CtB,IQiDzBrB,EAAQ4N,MACX3B,KRpD0B,GQoDTjM,EAAQ4N,KAEzB9N,EAAoB,CADpBC,EAASgM,EAAQwB,IAAQvN,EAAQuN,OAI7BrB,EAAMJ,EAAOwB,MAASpB,EAAIH,GAE/B7L,EAAO,GAAsB,mBAAX4P,EACjB,IAkEC,GAhEIhC,EAAW/B,EAASkB,MAClBkB,EACL,cAAe2B,GAAWA,EAAQtE,UAAUoF,OAKzCxC,GADJlC,EAAM4D,EAAQe,cACQpF,EAAcS,EAAGuB,KACnCa,EAAmBpC,EACpBkC,EACCA,EAASnB,MAAM6D,MACf5E,EAAGmB,GACJ5B,EAGCzL,EAAQyN,IAEXV,GADAZ,EAAIJ,EAAQ0B,IAAczN,EAAQyN,KACNJ,GAAwBlB,EAAC4E,KAGjD5C,EAEHpC,EAAQ0B,IAActB,EAAI,IAAI2D,EAAQhC,EAAUQ,IAGhDvC,EAAQ0B,IAActB,EAAI,IAAI8B,EAC7BH,EACAQ,GAEDnC,EAAE9K,YAAcyO,EAChB3D,EAAEyE,OAASI,GAER5C,GAAUA,EAAS6C,IAAI9E,GAE3BA,EAAEc,MAAQa,EACL3B,EAAEf,QAAOe,EAAEf,MAAQ,CAAE,GAC1Be,EAAE+B,QAAUI,EACZnC,EAAC2C,IAAkBrD,EACnBW,EAAQD,EAACqB,KAAA,EACTrB,EAAC+E,IAAoB,GACrB/E,EAACgF,IAAmB,IAIjBhD,GAAoC,MAAhBhC,EAACiF,MACxBjF,EAACiF,IAAcjF,EAAEf,OAGd+C,GAAwD,MAApC2B,EAAQuB,2BAC3BlF,EAACiF,KAAejF,EAAEf,QACrBe,EAACiF,IAAc7E,EAAO,CAAC,EAAGJ,EAACiF,MAG5B7E,EACCJ,EAACiF,IACDtB,EAAQuB,yBAAyBvD,EAAU3B,EAACiF,OAI9C/E,EAAWF,EAAEc,MACbT,EAAWL,EAAEf,MACbe,EAACuB,IAAU3B,EAGPK,EAEF+B,GACoC,MAApC2B,EAAQuB,0BACgB,MAAxBlF,EAAEmF,oBAEFnF,EAAEmF,qBAGCnD,GAA2C,MAAvBhC,EAAEoF,mBACzBpF,EAAC+E,IAAkBtO,KAAKuJ,EAAEoF,uBAErB,CAUN,GARCpD,GACoC,MAApC2B,EAAQuB,0BACRvD,IAAazB,GACkB,MAA/BF,EAAEqF,2BAEFrF,EAAEqF,0BAA0B1D,EAAUQ,IAIrCnC,EAACoB,MAC2B,MAA3BpB,EAAEsF,wBAAA,IACHtF,EAAEsF,sBACD3D,EACA3B,EAACiF,IACD9C,IAEDvC,EAAQ2B,MAAe1N,EAAQ0N,KAC/B,CAkBD,IAhBI3B,EAAQ2B,MAAe1N,EAAQ0N,MAKlCvB,EAAEc,MAAQa,EACV3B,EAAEf,MAAQe,EAACiF,IACXjF,EAACqB,KAAA,GAGFzB,EAAQwB,IAAQvN,EAAQuN,IACxBxB,EAAQqB,IAAapN,EAAQoN,IAC7BrB,EAAQqB,IAAWyC,MAAK,SAAA3P,GACnBA,IAAOA,EAAKmN,GAAWtB,EAC5B,IAESwC,EAAI,EAAGA,EAAIpC,EAACgF,IAAiB9Q,OAAQkO,IAC7CpC,EAAC+E,IAAkBtO,KAAKuJ,EAACgF,IAAiB5C,IAE3CpC,EAACgF,IAAmB,GAEhBhF,EAAC+E,IAAkB7Q,QACtBJ,EAAY2C,KAAKuJ,GAGlB,MAAMjM,CACP,CAE6B,MAAzBiM,EAAEuF,qBACLvF,EAAEuF,oBAAoB5D,EAAU3B,EAACiF,IAAa9C,GAG3CH,GAA4C,MAAxBhC,EAAEwF,oBACzBxF,EAAC+E,IAAkBtO,MAAK,WACvBuJ,EAAEwF,mBAAmBtF,EAAUG,EAAUG,EAC1C,GAEF,CASA,GAPAR,EAAE+B,QAAUI,EACZnC,EAAEc,MAAQa,EACV3B,EAACyC,IAAc1O,EACfiM,EAACoB,KAAA,EAEG2B,EAAapD,EAAO0C,IACvBY,EAAQ,EACLjB,EAAkB,CAQrB,IAPAhC,EAAEf,MAAQe,EAACiF,IACXjF,EAACqB,KAAA,EAEG0B,GAAYA,EAAWnD,GAE3BG,EAAMC,EAAEyE,OAAOzE,EAAEc,MAAOd,EAAEf,MAAOe,EAAE+B,SAE1B0B,EAAI,EAAGA,EAAIzD,EAACgF,IAAiB9Q,OAAQuP,IAC7CzD,EAAC+E,IAAkBtO,KAAKuJ,EAACgF,IAAiBvB,IAE3CzD,EAACgF,IAAmB,EACrB,MACC,GACChF,EAACqB,KAAA,EACG0B,GAAYA,EAAWnD,GAE3BG,EAAMC,EAAEyE,OAAOzE,EAAEc,MAAOd,EAAEf,MAAOe,EAAE+B,SAGnC/B,EAAEf,MAAQe,EAACiF,UACHjF,EAACqB,OAAa4B,EAAQ,IAIhCjD,EAAEf,MAAQe,EAACiF,IAEc,MAArBjF,EAAEyF,kBACLnG,EAAgBc,EAAOA,EAAO,CAAC,EAAGd,GAAgBU,EAAEyF,oBAGjDzD,IAAqB/B,GAAsC,MAA7BD,EAAE0F,0BACnClF,EAAWR,EAAE0F,wBAAwBxF,EAAUG,IAOhDyC,EACC/O,EACAoM,EAJGiD,EADI,MAAPrD,GAAeA,EAAIc,OAASgB,GAAuB,MAAX9B,EAAIgB,IACLhB,EAAIe,MAAML,SAAWV,GAIpCqD,EAAe,CAACA,GACxCxD,EACA/L,EACAyL,EACAO,EACAlM,EACAG,EACAF,EACAkM,EACAhI,GAGDkI,EAAEkC,KAAOtC,EAAQwB,IAGjBxB,EAAQ6B,MR5Pe,IQ8PnBzB,EAAC+E,IAAkB7Q,QACtBJ,EAAY2C,KAAKuJ,GAGdY,IACHZ,EAAC4E,IAAiB5E,EAACkB,GAAwB,KAoB7C,CAlBE,MAAOnN,GAGR,GAFA6L,EAAQ2B,IAAa,KAEjBzB,GAAoC,MAArBnM,EAA2B,CAK7C,IAJAiM,EAAQ6B,KAAW3B,EAChB,IRnRqB,GQsRjBlM,GAA8B,IAApBA,EAAO4P,UAAkB5P,EAAOsP,aAChDtP,EAASA,EAAOsP,YAEjBvP,EAAkBA,EAAkBgS,QAAQ/R,IAAW,KACvDgM,EAAQwB,IAAQxN,CACjB,MACCgM,EAAQwB,IAAQvN,EAAQuN,IACxBxB,EAAQqB,IAAapN,EAAQoN,IAE9BtB,EAAOyB,IAAarN,EAAG6L,EAAU/L,EAClC,MAEqB,MAArBF,GACAiM,EAAQ2B,MAAe1N,EAAQ0N,KAE/B3B,EAAQqB,IAAapN,EAAQoN,IAC7BrB,EAAQwB,IAAQvN,EAAQuN,KAExBxB,EAAQwB,IAAQwE,EACf/R,EAAQuN,IACRxB,EACA/L,EACAyL,EACAO,EACAlM,EACAG,EACAgM,EACAhI,IAIGiI,EAAMJ,EAAQkG,SAAS9F,EAAIH,EACjC,CAOgB,SAAAiD,EAAW9O,EAAa6L,EAAM/L,GAC7C+L,EAAIyB,SAAA,EAEJ,IAAK,IAAI/B,EAAI,EAAGA,EAAIzL,EAASK,OAAQoL,IACpC0D,EAASnP,EAASyL,GAAIzL,IAAWyL,GAAIzL,IAAWyL,IAG7CK,EAAO2B,KAAU3B,EAAO2B,IAAS1B,EAAM7L,GAE3CA,EAAY2P,MAAK,SAAA9D,GAChB,IAEC7L,EAAc6L,EAACmF,IACfnF,EAACmF,IAAoB,GACrBhR,EAAY2P,MAAK,SAAA3P,GAEhBA,EAAG2M,KAAKd,EACT,GAGD,CAFE,MAAO7L,GACR4L,EAAOyB,IAAarN,EAAG6L,EAAC2B,IACzB,CACD,GACD,CAiBA,SAASqE,EACRhG,EACA/L,EACAyL,EACAO,EACAlM,EACAG,EACAF,EACAkM,EACAhI,GATD,IAeKiI,EAEAE,EAEAC,EAEAE,EACAI,EACAI,EACAe,EAbAE,EAAWvC,EAASwB,MACpBgB,EAAWjO,EAASiN,MACpBmB,EAAkCpO,EAASgN,KAmB/C,GALiB,QAAboB,EAAoBtO,EAAY,6BACd,SAAbsO,EACRtO,EAAY,qCACHA,IAAWA,EAAY,gCAER,MAArBG,EACH,IAAKiM,EAAI,EAAGA,EAAIjM,EAAkBI,OAAQ6L,IAMzC,IALAS,EAAQ1M,EAAkBiM,KAOzB,iBAAkBS,KAAYyB,IAC7BA,EAAWzB,EAAMsF,YAAc7D,EAA8B,IAAnBzB,EAAMgD,UAChD,CACD5D,EAAMY,EACN1M,EAAkBiM,GAAK,KACvB,KACD,CAIF,GAAW,MAAPH,EAAa,CAChB,GAAiB,OAAbqC,EACH,OAAO8D,SAASC,eAAelE,GAGhClC,EAAMmG,SAASE,gBACdtS,EACAsO,EACAH,EAASoE,IAAMpE,GAKZhC,IACCH,EAAOwG,KACVxG,EAAOwG,IAAoBtS,EAAUC,GACtCgM,GAAA,GAGDhM,EAAoB,IACrB,CAEA,GAAiB,OAAbmO,EAECJ,IAAaC,GAAchC,GAAeF,EAAIjJ,OAASmL,IAC1DlC,EAAIjJ,KAAOmL,OAEN,CASN,GAPAhO,EAAoBA,GAAqBC,EAAM2M,KAAKd,EAAIwG,YAExDvE,EAAWvC,EAASwB,OAASd,GAKxBF,GAAoC,MAArBhM,EAEnB,IADA+N,EAAW,CAAE,EACR9B,EAAI,EAAGA,EAAIH,EAAIyG,WAAWnS,OAAQ6L,IAEtC8B,GADArB,EAAQZ,EAAIyG,WAAWtG,IACRuG,MAAQ9F,EAAMmE,MAI/B,IAAK5E,KAAK8B,EAET,GADArB,EAAQqB,EAAS9B,GACR,YAALA,QACG,GAAS,2BAALA,EACVG,EAAUM,OACA,KAAET,KAAK+B,GAAW,CAC5B,GACO,SAAL/B,GAAgB,iBAAkB+B,GAC7B,WAAL/B,GAAkB,mBAAoB+B,EAEvC,SAEDgC,EAAYlE,EAAKG,EAAG,KAAMS,EAAO7M,EAClC,CAKD,IAAKoM,KAAK+B,EACTtB,EAAQsB,EAAS/B,GACR,YAALA,EACHK,EAAcI,EACC,2BAALT,EACVE,EAAUO,EACK,SAALT,EACVa,EAAaJ,EACE,WAALT,EACV4B,EAAUnB,EAERV,GAA+B,mBAATU,GACxBqB,EAAS9B,KAAOS,GAEhBsD,EAAYlE,EAAKG,EAAGS,EAAOqB,EAAS9B,GAAIpM,GAK1C,GAAIsM,EAGDH,GACCI,IACAD,EAAOsG,SAAYrG,EAAOqG,QAC1BtG,EAAOsG,SAAY3G,EAAI4G,aAEzB5G,EAAI4G,UAAYvG,EAAOsG,QAGxB1S,EAAQoN,IAAa,QAuBrB,GArBIf,IAASN,EAAI4G,UAAY,IAE7B1D,EACClD,EACAO,EAAQC,GAAeA,EAAc,CAACA,GACtCvM,EACAyL,EACAO,EACa,kBAAboC,EACG,+BACAtO,EACHG,EACAF,EACAE,EACGA,EAAkB,GAClBwL,EAAQ2B,KAAce,EAAc1C,EAAU,GACjDQ,EACAhI,GAIwB,MAArBhE,EACH,IAAKiM,EAAIjM,EAAkBI,OAAQ6L,KAClCM,EAAWvM,EAAkBiM,IAM3BD,IACJC,EAAI,QACa,aAAbkC,GAAyC,MAAdrB,EAC9BhB,EAAIyE,gBAAgB,kBAEpBzD,IAKCA,IAAehB,EAAIG,IACL,aAAbkC,IAA4BrB,GAIf,WAAbqB,GAAyBrB,IAAeiB,EAAS9B,KAEnD+D,EAAYlE,EAAKG,EAAGa,EAAYiB,EAAS9B,GAAIpM,GAG9CoM,EAAI,mBACA4B,GAAyBA,IAAY/B,EAAIG,IAC5C+D,EAAYlE,EAAKG,EAAG4B,EAASE,EAAS9B,GAAIpM,GAG7C,CAEA,OAAOiM,CACR,CAQgB,SAAAoD,EAASjP,EAAK6L,EAAO/L,GACpC,IACC,GAAkB,mBAAPE,EAAmB,CAC7B,IAAIuL,EAAuC,mBAAhBvL,EAAG0N,IAC1BnC,GAEHvL,EAAG0N,MAGCnC,GAA0B,MAATM,IAIrB7L,EAAG0N,IAAY1N,EAAI6L,GAErB,MAAO7L,EAAI6N,QAAUhC,CAGtB,CAFE,MAAO7L,GACR4L,EAAOyB,IAAarN,EAAGF,EACxB,CACD,CASgB,SAAAwP,EAAQtP,EAAO6L,EAAa/L,GAA5B,IACXyL,EAsBMO,EAbV,GARIF,EAAQ8G,SAAS9G,EAAQ8G,QAAQ1S,IAEhCuL,EAAIvL,EAAMiN,OACT1B,EAAEsC,SAAWtC,EAAEsC,UAAY7N,EAAKqN,KACpC4B,EAAS1D,EAAG,KAAMM,IAIU,OAAzBN,EAAIvL,EAAKuN,KAAsB,CACnC,GAAIhC,EAAEoH,qBACL,IACCpH,EAAEoH,sBAGH,CAFE,MAAO3S,GACR4L,EAAOyB,IAAarN,EAAG6L,EACxB,CAGDN,EAAE4C,KAAO5C,EAACmD,IAAc,IACzB,CAEA,GAAKnD,EAAIvL,EAAKkN,IACb,IAASpB,EAAI,EAAGA,EAAIP,EAAEpL,OAAQ2L,IACzBP,EAAEO,IACLwD,EACC/D,EAAEO,GACFD,EACA/L,GAAmC,mBAAdE,EAAM8M,MAM1BhN,GACJwM,EAAWtM,EAAKqN,KAKjBrN,EAAKuN,IAAcvN,EAAKmN,GAAWnN,EAAKqN,IAAQrN,EAAKsN,SAAA,CACtD,CAGA,SAASwD,EAAS9Q,EAAO4L,EAAOC,GAC/B,OAAOpK,KAAKN,YAAYnB,EAAO6L,EAChC,UCpnBgB+G,EAAO/G,EAAO/L,EAAWyL,GAAA,IAMpCO,EAOAlM,EAQAG,EACHF,EArBG+L,EAAOuB,IAAQvB,EAAOuB,GAAOtB,EAAO/L,GAYpCF,GAPAkM,EAAoC,mBAAfP,GAQtB,KACCA,GAAeA,EAAW2B,KAAepN,EAASoN,IAMlDnN,EAAc,GACjBF,EAAW,GACZ8O,EACC7O,EAPD+L,IAAWC,GAAeP,GAAgBzL,GAASoN,IAClDT,EAAcqB,EAAU,KAAM,CAACjC,IAU/BjM,GAAYqM,EACZA,EACAnM,EAAU+O,cACT/C,GAAeP,EACb,CAACA,GACD3L,EACC,KACAE,EAAU+S,WACT7S,EAAM2M,KAAK7M,EAAUuS,YACrB,KACLtS,GACC+L,GAAeP,EACbA,EACA3L,EACCA,EAAQyN,IACRvN,EAAU+S,WACd/G,EACAjM,GAIDiP,EAAW/O,EAAa8L,EAAOhM,EAChC,CAOgB,SAAAiT,EAAQ9S,EAAO4L,GAC9BgH,EAAO5S,EAAO4L,EAAWkH,EAC1B,CC5DO,SAASC,EAAanH,EAAOC,EAAO/L,GAApC,IAELyL,EACAO,EACAlM,EAEGG,EALAF,EAAkBwM,EAAO,CAAE,EAAET,EAAMmB,OAWvC,IAAKnN,KAJDgM,EAAMkB,MAAQlB,EAAMkB,KAAKF,eAC5B7M,EAAe6L,EAAMkB,KAAKF,cAGjBf,EACA,OAALjM,EAAY2L,EAAMM,EAAMjM,GACd,OAALA,EAAYkM,EAAMD,EAAMjM,GAEhCC,EAAgBD,QAAA,IADRiM,EAAMjM,SAAA,IAAoBG,EACbA,EAAaH,GAEbiM,EAAMjM,GAS7B,OALIS,UAAUF,OAAS,IACtBN,EAAgB6M,SACfrM,UAAUF,OAAS,EAAIH,EAAM2M,KAAKtM,UAAW,GAAKP,GAG7C+M,EACNjB,EAAMkB,KACNjN,EACA0L,GAAOK,EAAMoB,IACblB,GAAOF,EAAMqB,IACb,KAEF,UJ1CgB+F,EAAchT,EAAc4L,GAG3C,IAAMC,EAAU,CACf0B,IAHD3B,EAAY,OAASI,IAIpBmB,GAAenN,EAEfiT,SAAA,SAASjT,EAAO4L,GAIf,OAAO5L,EAAM0M,SAASd,EACvB,EAEAsH,SAAQ,SAAClT,GAAD,IAGF6L,EACA/L,EA8BL,OAjCK2B,KAAKiQ,kBAEL7F,EAAO,IACP/L,EAAM,CAAC,GACP8L,GAAanK,KAEjBA,KAAKiQ,gBAAkB,WAAM,OAAA5R,CAAG,EAEhC2B,KAAKkR,qBAAuB,WAC3B9G,EAAO,IACR,EAEApK,KAAK8P,sBAAwB,SAAUvR,GAClCyB,KAAKsL,MAAM6D,QAAU5Q,EAAO4Q,OAC/B/E,EAAK8D,MAAK,SAAA3P,GACTA,EAACqN,KAAA,EACDe,EAAcpO,EACf,GAEF,EAEAyB,KAAKsP,IAAM,SAAA/Q,GACV6L,EAAKnJ,KAAK1C,GACV,IAAI4L,EAAM5L,EAAE2S,qBACZ3S,EAAE2S,qBAAuB,WACpB9G,GACHA,EAAKsH,OAAOtH,EAAK+F,QAAQ5R,GAAI,GAE1B4L,GAAKA,EAAIe,KAAK3M,EACnB,CACD,GAGMA,EAAM0M,QACd,GASD,OAAQb,EAAQqH,SAAQ/F,GAAetB,EAAQoH,SAAStC,YACvD9E,CACF,CLrCa7L,EAAQkM,EAAUiE,MChBzBvE,EAAU,CACfyB,ISHe,SAAYrN,EAAO4L,EAAOC,EAAU/L,GAQnD,IANA,IAAIyL,EAEHO,EAEAlM,EAEOgM,EAAQA,EAAKuB,IACpB,IAAK5B,EAAYK,EAAK2B,OAAiBhC,EAAS4B,GAC/C,IAcC,IAbArB,EAAOP,EAAUpK,cAE4B,MAAjC2K,EAAKsH,2BAChB7H,EAAU8H,SAASvH,EAAKsH,yBAAyBpT,IACjDJ,EAAU2L,EAAS+B,KAGe,MAA/B/B,EAAU+H,oBACb/H,EAAU+H,kBAAkBtT,EAAOF,GAAa,CAAE,GAClDF,EAAU2L,EAAS+B,KAIhB1N,EACH,OAAQ2L,EAASsF,IAAiBtF,CAIpC,CAFE,MAAOK,GACR5L,EAAQ4L,CACT,CAIF,MAAM5L,CACP,GRxCI6L,EAAU,EAgGD/L,EAAiB,SAAAE,GAAK,OACzB,MAATA,GAAsC,MAArBA,EAAMmB,WAAwB,ECzEhD4M,EAAczC,UAAU+H,SAAW,SAAUrT,EAAQ4L,GAEpD,IAAIC,EAEHA,EADsB,MAAnBpK,KAAIyP,KAAuBzP,KAAIyP,MAAgBzP,KAAKyJ,MACnDzJ,KAAIyP,IAEJzP,KAAIyP,IAAc7E,EAAO,CAAE,EAAE5K,KAAKyJ,OAGlB,mBAAVlL,IAGVA,EAASA,EAAOqM,EAAO,CAAC,EAAGR,GAAIpK,KAAKsL,QAGjC/M,GACHqM,EAAOR,EAAG7L,GAIG,MAAVA,GAEAyB,KAAI+L,MACH5B,GACHnK,KAAIwP,IAAiBvO,KAAKkJ,GAE3BwC,EAAc3M,MAEhB,EAQAsM,EAAczC,UAAUiI,YAAc,SAAUvT,GAC3CyB,KAAI+L,MAIP/L,KAAI4L,KAAA,EACArN,GAAUyB,KAAIuP,IAAkBtO,KAAK1C,GACzCoO,EAAc3M,MAEhB,EAYAsM,EAAczC,UAAUoF,OAAS5C,EA8F7BvC,EAAgB,GAad3L,EACa,mBAAX4T,QACJA,QAAQlI,UAAUmI,KAAKC,KAAKF,QAAQG,WACpCC,WAuBE7T,EAAY,SAACC,EAAG4L,GAAM,OAAA5L,EAACwN,IAAAJ,IAAiBxB,EAAC4B,IAAAJ,GAAc,EAuB7DiB,EAAOC,IAAkB,ECtNrBzO,EAAa,EAmJXkM,EAAayE,GAAA,GACbzM,EAAoByM,GAAA,GC5KfxE,EAAI,C,wQMCXlM,EAGAF,EAGAiM,EAmBAN,E,WAhBAO,EAAc,EAGd/L,EAAoB,GAGlBgM,EAAuD/L,EAAAA,QAEzDH,EAAgBkM,EAAOqB,IACvBpB,EAAkBD,EAAOuC,IACzBpC,EAAeH,EAAQ+F,OACvBlG,EAAYG,EAAOwB,IACnBK,EAAmB7B,EAAQ2G,QAC3B3O,EAAUgI,EAAOoB,GA8GrB,SAASd,EAAarM,EAAOF,GACxBiM,EAAOiF,KACVjF,EAAOiF,IAAOpR,EAAkBI,EAAO8L,GAAehM,GAEvDgM,EAAc,EAOd,IAAMD,EACLjM,EAAgBiU,MACfjU,EAAgBiU,IAAW,CAC3B1G,GAAO,GACP6D,IAAiB,KAOnB,OAJIhR,GAAS6L,EAAKsB,GAAOhN,QACxB0L,EAAKsB,GAAOzK,KAAK,CAAE,GAGbmJ,EAAKsB,GAAOnN,EACpB,CAOO,SAASiM,EAASjM,GAExB,OADA8L,EAAc,EACPK,EAAW2G,EAAgB9S,EACnC,CAUgB,SAAAmM,EAAWnM,EAAS6L,EAAcN,GAEjD,IAAMO,EAAYO,EAAavM,IAAgB,GAE/C,GADAgM,EAAUhM,EAAWE,GAChB8L,EAASyB,MACbzB,EAASqB,GAAU,CACjB5B,EAAiDA,EAAKM,GAA/CiH,OAAA,EAA0BjH,GAElC,SAAA7L,GACC,IAAMF,EAAegM,EAASgI,IAC3BhI,EAASgI,IAAY,GACrBhI,EAASqB,GAAQ,GACdvN,EAAYkM,EAAUhM,EAASA,EAAcE,GAE/CF,IAAiBF,IACpBkM,EAASgI,IAAc,CAAClU,EAAWkM,EAASqB,GAAQ,IACpDrB,EAASyB,IAAY8F,SAAS,CAAE,GAElC,GAGDvH,EAASyB,IAAc3N,GAElBA,EAAiBiM,GAAkB,CAgC9B,IAAA9L,EAAT,SAAyBC,EAAGF,EAAGF,GAC9B,IAAKkM,EAASyB,IAAAsG,IAAqB,OAAO,EAG1C,IACMhI,EACLC,EAASyB,IAAAsG,IAAA1G,GAA0B4G,QAFhB,SAAA/T,GAAC,QAAMA,EAACuN,GAAW,IAOvC,GAHsB1B,EAAWmI,OAAM,SAAAhU,GAAC,OAAKA,EAAC8T,GAAW,IAIxD,OAAO/H,GAAUA,EAAQY,KAAKlL,KAAMzB,EAAGF,EAAGF,GAM3C,IAAI2L,GAAA,EAUJ,OATAM,EAAWoI,SAAQ,SAAAjU,GAClB,GAAIA,EAAQ8T,IAAa,CACxB,IAAMhU,EAAeE,EAAQmN,GAAQ,GACrCnN,EAAQmN,GAAUnN,EAAQ8T,IAC1B9T,EAAQ8T,SAAA,EACJhU,IAAiBE,EAAQmN,GAAQ,KAAI5B,GAAA,EAC1C,CACD,OAEOA,GAAgBO,EAASyB,IAAYR,QAAU/M,MACnD+L,GACCA,EAAQY,KAAKlL,KAAMzB,EAAGF,EAAGF,GAG9B,EAhEAA,EAAiBiM,GAAA,EACjB,IAAIE,EAAUnM,EAAiB2R,sBACzB1R,EAAUD,EAAiB4R,oBAKjC5R,EAAiB4R,oBAAsB,SAAUxR,EAAGF,EAAGF,GACtD,GAAI6B,KAAI4L,IAAS,CAChB,IAAIxB,EAAME,EAEVA,OAAA,EACAhM,EAAgBC,EAAGF,EAAGF,GACtBmM,EAAUF,CACX,CAEIhM,GAASA,EAAQ8M,KAAKlL,KAAMzB,EAAGF,EAAGF,EACvC,EAiDAA,EAAiB2R,sBAAwBxR,CAC1C,CAGD,OAAO+L,EAASgI,KAAehI,EAASqB,EACzC,CAOgB,SAAAf,EAAUpM,EAAU6L,GAEnC,IAAMN,EAAQc,EAAavM,IAAgB,IACtCiM,EAAOmF,KAAiBhD,EAAY3C,EAAKsI,IAAQhI,KACrDN,EAAK4B,GAAUnN,EACfuL,EAAMA,EAAeM,EAErBjM,EAAgBiU,IAAA7C,IAAyBtO,KAAK6I,GAEhD,CAOO,SAASkB,EAAgBzM,EAAU6L,GAEzC,IAAMN,EAAQc,EAAavM,IAAgB,IACtCiM,EAAOmF,KAAiBhD,EAAY3C,EAAKsI,IAAQhI,KACrDN,EAAK4B,GAAUnN,EACfuL,EAAMA,EAAeM,EAErBjM,EAAgBoR,IAAkBtO,KAAK6I,GAEzC,CAGO,SAASwE,EAAO/P,GAEtB,OADA8L,EAAc,EACP8D,GAAQ,WAAO,OAAE/B,QAAS7N,EAAc,GAAG,GACnD,CAQgB,SAAAwQ,EAAoBxQ,EAAKF,EAAcF,GACtDkM,EAAc,EACdW,GACC,WACC,MAAkB,mBAAPzM,GACVA,EAAIF,KACS,kBAAAE,EAAI,KAAK,GACZA,GACVA,EAAI6N,QAAU/N,IACA,kBAAAE,EAAI6N,QAAU,IAAI,SAElC,GACQ,MAARjO,EAAeA,EAAOA,EAAKsU,OAAOlU,GAEpC,CAQgB,SAAA4P,EAAQ5P,EAASJ,GAEhC,IAAMiM,EAAQQ,EAAavM,IAAgB,GAO3C,OANIoO,EAAYrC,EAAKgI,IAAQjU,KAC5BiM,EAAKsB,GAAUnN,IACf6L,EAAKgI,IAASjU,EACdiM,EAAKmF,IAAYhR,GAGX6L,EAAKsB,EACb,CAOO,SAAS2D,EAAY9Q,EAAUF,GAErC,OADAgM,EAAc,EACP8D,GAAQ,kBAAM5P,CAAQ,GAAEF,EAChC,CAKO,SAASmO,EAAWjO,GAC1B,IAAM6L,EAAWjM,EAAiBoO,QAAQhO,EAAOuN,KAK3ChC,EAAQc,EAAavM,IAAgB,GAK3C,OADAyL,EAAKQ,EAAY/L,EACZ6L,GAEe,MAAhBN,EAAK4B,KACR5B,EAAK4B,IAAA,EACLtB,EAASkF,IAAInR,IAEPiM,EAASkB,MAAM6D,OANA5Q,EAAOmN,EAO9B,CAMO,SAASkB,EAAcrO,EAAOF,GAChCiM,EAAQoI,eACXpI,EAAQoI,cACPrU,EAAYA,EAAUE,GAAMA,EAG/B,CAMO,SAAS8N,EAAiB9N,GAEhC,IAAM6L,EAAQQ,EAAavM,IAAgB,IACrCyL,EAAWU,IAQjB,OAPAJ,EAAKsB,GAAUnN,EACVJ,EAAiB0T,oBACrB1T,EAAiB0T,kBAAoB,SAACtT,EAAKF,GACtC+L,EAAKsB,IAAStB,EAAKsB,GAAQnN,EAAKF,GACpCyL,EAAS,GAAGvL,EACb,GAEM,CACNuL,EAAS,GACT,WACCA,EAAS,QAAG,EACb,EAEF,CAGO,SAASsB,IAEf,IAAM7M,EAAQqM,EAAavM,IAAgB,IAC3C,IAAKE,EAAKmN,GAAS,CAIlB,IADA,IAAItB,EAAOjM,EAAgB4N,IACX,OAAT3B,IAAkBA,EAAIuG,KAA2B,OAAjBvG,EAAIsB,IAC1CtB,EAAOA,EAAIsB,GAGZ,IAAI5B,EAAOM,EAAIuG,MAAWvG,EAAIuG,IAAS,CAAC,EAAG,IAC3CpS,EAAKmN,GAAU,IAAM5B,EAAK,GAAK,IAAMA,EAAK,IAC3C,CAEA,OAAOvL,EAAKmN,EACb,CAKA,SAAS2B,IAER,IADA,IAAI9O,EACIA,EAAYD,EAAkB0O,SACrC,GAAKzO,EAAS0O,KAAgB1O,EAAS6T,IACvC,IACC7T,EAAS6T,IAAA7C,IAAyBiD,QAAQpC,GAC1C7R,EAAS6T,IAAA7C,IAAyBiD,QAAQrB,GAC1C5S,EAAS6T,IAAA7C,IAA2B,EAIrC,CAHE,MAAOlR,GACRE,EAAS6T,IAAA7C,IAA2B,GACpCjF,EAAOsB,IAAavN,EAAGE,EAASwN,IACjC,CAEF,CAzaAzB,EAAOqB,IAAS,SAAApN,GACfJ,EAAmB,KACfC,GAAeA,EAAcG,EAClC,EAEA+L,EAAOoB,GAAS,SAACnN,EAAOF,GACnBE,GAASF,EAASoN,KAAcpN,EAASoN,IAAAkF,MAC5CpS,EAAKoS,IAAStS,EAASoN,IAAAkF,KAGpBrO,GAASA,EAAQ/D,EAAOF,EAC7B,EAGAiM,EAAOuC,IAAW,SAAAtO,GACbgM,GAAiBA,EAAgBhM,GAGrCF,EAAe,EAEf,IAAMyL,GAHN3L,EAAmBI,EAAKuN,KAGMsG,IAC1BtI,IACCM,IAAsBjM,GACzB2L,EAAKyF,IAAmB,GACxBpR,EAAgBoR,IAAoB,GACpCzF,EAAK4B,GAAO8G,SAAQ,SAAAjU,GACfA,EAAQ8T,MACX9T,EAAQmN,GAAUnN,EAAQ8T,KAE3B9T,EAASuL,EAAevL,EAAQ8T,SAAA,CACjC,MAEAvI,EAAKyF,IAAiBiD,QAAQpC,GAC9BtG,EAAKyF,IAAiBiD,QAAQrB,GAC9BrH,EAAKyF,IAAmB,GACxBlR,EAAe,IAGjB+L,EAAoBjM,CACrB,EAGAmM,EAAQ+F,OAAS,SAAA9R,GACZkM,GAAcA,EAAalM,GAE/B,IAAMF,EAAIE,EAAKuN,IACXzN,GAAKA,EAAC+T,MACL/T,EAAC+T,IAAA7C,IAAyB7Q,SA+ZR,IA/Z2BJ,EAAkB2C,KAAK5C,IA+Z7CyL,IAAYQ,EAAQqI,yBAC/C7I,EAAUQ,EAAQqI,wBACN9H,GAAgBwC,IAha5BhP,EAAC+T,IAAA1G,GAAe8G,SAAQ,SAAAjU,GACnBA,EAASuL,IACZvL,EAAQ6T,IAAS7T,EAASuL,GAE3BvL,EAASuL,OAAA,CACV,KAEDM,EAAoBjM,EAAmB,IACxC,EAIAmM,EAAOwB,IAAW,SAACvN,EAAOF,GACzBA,EAAY6P,MAAK,SAAA3P,GAChB,IACCA,EAASgR,IAAkBiD,QAAQpC,GACnC7R,EAASgR,IAAoBhR,EAASgR,IAAkB+C,QAAO,SAAA/T,GAAE,OAChEA,EAAEmN,IAAUyF,EAAa5S,EAAU,GAQrC,CANE,MAAOJ,GACRE,EAAY6P,MAAK,SAAA3P,GACZA,EAACgR,MAAmBhR,EAACgR,IAAoB,GAC9C,IACAlR,EAAc,GACdiM,EAAOsB,IAAazN,EAAGI,EAASwN,IACjC,CACD,IAEI5B,GAAWA,EAAU5L,EAAOF,EACjC,EAGAiM,EAAQ2G,QAAU,SAAA1S,GACb4N,GAAkBA,EAAiB5N,GAEvC,IAEKF,EAFCF,EAAII,EAAKuN,IACX3N,GAAKA,EAACiU,MAETjU,EAACiU,IAAA1G,GAAe8G,SAAQ,SAAAjU,GACvB,IACC6R,EAAc7R,EAGf,CAFE,MAAOA,GACRF,EAAaE,CACd,CACD,IACAJ,EAACiU,SAAA,EACG/T,GAAYiM,EAAOsB,IAAavN,EAAYF,EAAC4N,KAEnD,EA2UA,IAAIO,EAA0C,mBAAzBqG,sBAYrB,SAAS9H,EAAetM,GACvB,IAOIF,EAPEF,EAAO,WACZyU,aAAaxI,GACTkC,GAASuG,qBAAqBxU,GAClC8T,WAAW5T,EACZ,EACM6L,EAAU+H,WAAWhU,EAjcR,KAocfmO,IACHjO,EAAMsU,sBAAsBxU,GAE9B,CAqBA,SAASiS,EAAc7R,GAGtB,IAAMF,EAAOF,EACTiM,EAAU7L,EAAIuN,IACI,mBAAX1B,IACV7L,EAAIuN,SAAA,EACJ1B,KAGDjM,EAAmBE,CACpB,CAOA,SAAS8S,EAAa5S,GAGrB,IAAMF,EAAOF,EACbI,EAAIuN,IAAYvN,EAAImN,KACpBvN,EAAmBE,CACpB,CAOA,SAASoO,EAAYlO,EAASF,GAC7B,OACEE,GACDA,EAAQG,SAAWL,EAAQK,QAC3BL,EAAQ6P,MAAK,SAAC7P,EAAKF,GAAU,OAAAE,IAAQE,EAAQJ,EAAM,GAErD,CAQA,SAASkT,EAAe9S,EAAKF,GAC5B,MAAmB,mBAALA,EAAkBA,EAAEE,GAAOF,CAC1C,C","sources":["../node_modules/clsx/dist/clsx.m.js","../node_modules/keccak/js.js","../node_modules/keccak/lib/api/index.js","../node_modules/keccak/lib/api/keccak.js","../node_modules/keccak/lib/api/shake.js","../node_modules/keccak/lib/keccak-state-unroll.js","../node_modules/keccak/lib/keccak.js","../node_modules/preact/src/constants.js","../node_modules/preact/src/util.js","../node_modules/preact/src/options.js","../node_modules/preact/src/create-element.js","../node_modules/preact/src/component.js","../node_modules/preact/src/diff/props.js","../node_modules/preact/src/create-context.js","../node_modules/preact/src/diff/children.js","../node_modules/preact/src/diff/index.js","../node_modules/preact/src/render.js","../node_modules/preact/src/clone-element.js","../node_modules/preact/src/diff/catch-error.js","../node_modules/preact/hooks/src/index.js"],"sourcesContent":["function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","module.exports = require('./lib/api')(require('./lib/keccak'))\n","const createKeccak = require('./keccak')\nconst createShake = require('./shake')\n\nmodule.exports = function (KeccakState) {\n  const Keccak = createKeccak(KeccakState)\n  const Shake = createShake(KeccakState)\n\n  return function (algorithm, options) {\n    const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm\n    switch (hash) {\n      case 'keccak224': return new Keccak(1152, 448, null, 224, options)\n      case 'keccak256': return new Keccak(1088, 512, null, 256, options)\n      case 'keccak384': return new Keccak(832, 768, null, 384, options)\n      case 'keccak512': return new Keccak(576, 1024, null, 512, options)\n\n      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)\n      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)\n      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)\n      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)\n\n      case 'shake128': return new Shake(1344, 256, 0x1f, options)\n      case 'shake256': return new Shake(1088, 512, 0x1f, options)\n\n      default: throw new Error('Invald algorithm: ' + algorithm)\n    }\n  }\n}\n","const { Transform } = require('readable-stream')\n\nmodule.exports = (KeccakState) => class Keccak extends Transform {\n  constructor (rate, capacity, delimitedSuffix, hashBitLength, options) {\n    super(options)\n\n    this._rate = rate\n    this._capacity = capacity\n    this._delimitedSuffix = delimitedSuffix\n    this._hashBitLength = hashBitLength\n    this._options = options\n\n    this._state = new KeccakState()\n    this._state.initialize(rate, capacity)\n    this._finalized = false\n  }\n\n  _transform (chunk, encoding, callback) {\n    let error = null\n    try {\n      this.update(chunk, encoding)\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  _flush (callback) {\n    let error = null\n    try {\n      this.push(this.digest())\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  update (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\n    if (this._finalized) throw new Error('Digest already called')\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n    this._state.absorb(data)\n\n    return this\n  }\n\n  digest (encoding) {\n    if (this._finalized) throw new Error('Digest already called')\n    this._finalized = true\n\n    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)\n    let digest = this._state.squeeze(this._hashBitLength / 8)\n    if (encoding !== undefined) digest = digest.toString(encoding)\n\n    this._resetState()\n\n    return digest\n  }\n\n  // remove result from memory\n  _resetState () {\n    this._state.initialize(this._rate, this._capacity)\n    return this\n  }\n\n  // because sometimes we need hash right now and little later\n  _clone () {\n    const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)\n    this._state.copy(clone._state)\n    clone._finalized = this._finalized\n\n    return clone\n  }\n}\n","const { Transform } = require('readable-stream')\n\nmodule.exports = (KeccakState) => class Shake extends Transform {\n  constructor (rate, capacity, delimitedSuffix, options) {\n    super(options)\n\n    this._rate = rate\n    this._capacity = capacity\n    this._delimitedSuffix = delimitedSuffix\n    this._options = options\n\n    this._state = new KeccakState()\n    this._state.initialize(rate, capacity)\n    this._finalized = false\n  }\n\n  _transform (chunk, encoding, callback) {\n    let error = null\n    try {\n      this.update(chunk, encoding)\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  _flush () {}\n\n  _read (size) {\n    this.push(this.squeeze(size))\n  }\n\n  update (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\n    if (this._finalized) throw new Error('Squeeze already called')\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n    this._state.absorb(data)\n\n    return this\n  }\n\n  squeeze (dataByteLength, encoding) {\n    if (!this._finalized) {\n      this._finalized = true\n      this._state.absorbLastFewBits(this._delimitedSuffix)\n    }\n\n    let data = this._state.squeeze(dataByteLength)\n    if (encoding !== undefined) data = data.toString(encoding)\n\n    return data\n  }\n\n  _resetState () {\n    this._state.initialize(this._rate, this._capacity)\n    return this\n  }\n\n  _clone () {\n    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)\n    this._state.copy(clone._state)\n    clone._finalized = this._finalized\n\n    return clone\n  }\n}\n","const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]\n\nexports.p1600 = function (s) {\n  for (let round = 0; round < 24; ++round) {\n    // theta\n    const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]\n    const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]\n    const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]\n    const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]\n    const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]\n    const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]\n    const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]\n    const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]\n    const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]\n    const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]\n\n    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)\n    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)\n    const t1slo0 = s[0] ^ lo\n    const t1shi0 = s[1] ^ hi\n    const t1slo5 = s[10] ^ lo\n    const t1shi5 = s[11] ^ hi\n    const t1slo10 = s[20] ^ lo\n    const t1shi10 = s[21] ^ hi\n    const t1slo15 = s[30] ^ lo\n    const t1shi15 = s[31] ^ hi\n    const t1slo20 = s[40] ^ lo\n    const t1shi20 = s[41] ^ hi\n    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)\n    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)\n    const t1slo1 = s[2] ^ lo\n    const t1shi1 = s[3] ^ hi\n    const t1slo6 = s[12] ^ lo\n    const t1shi6 = s[13] ^ hi\n    const t1slo11 = s[22] ^ lo\n    const t1shi11 = s[23] ^ hi\n    const t1slo16 = s[32] ^ lo\n    const t1shi16 = s[33] ^ hi\n    const t1slo21 = s[42] ^ lo\n    const t1shi21 = s[43] ^ hi\n    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)\n    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)\n    const t1slo2 = s[4] ^ lo\n    const t1shi2 = s[5] ^ hi\n    const t1slo7 = s[14] ^ lo\n    const t1shi7 = s[15] ^ hi\n    const t1slo12 = s[24] ^ lo\n    const t1shi12 = s[25] ^ hi\n    const t1slo17 = s[34] ^ lo\n    const t1shi17 = s[35] ^ hi\n    const t1slo22 = s[44] ^ lo\n    const t1shi22 = s[45] ^ hi\n    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)\n    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)\n    const t1slo3 = s[6] ^ lo\n    const t1shi3 = s[7] ^ hi\n    const t1slo8 = s[16] ^ lo\n    const t1shi8 = s[17] ^ hi\n    const t1slo13 = s[26] ^ lo\n    const t1shi13 = s[27] ^ hi\n    const t1slo18 = s[36] ^ lo\n    const t1shi18 = s[37] ^ hi\n    const t1slo23 = s[46] ^ lo\n    const t1shi23 = s[47] ^ hi\n    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)\n    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)\n    const t1slo4 = s[8] ^ lo\n    const t1shi4 = s[9] ^ hi\n    const t1slo9 = s[18] ^ lo\n    const t1shi9 = s[19] ^ hi\n    const t1slo14 = s[28] ^ lo\n    const t1shi14 = s[29] ^ hi\n    const t1slo19 = s[38] ^ lo\n    const t1shi19 = s[39] ^ hi\n    const t1slo24 = s[48] ^ lo\n    const t1shi24 = s[49] ^ hi\n\n    // rho & pi\n    const t2slo0 = t1slo0\n    const t2shi0 = t1shi0\n    const t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)\n    const t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)\n    const t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)\n    const t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)\n    const t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)\n    const t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)\n    const t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)\n    const t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)\n    const t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)\n    const t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)\n    const t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)\n    const t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)\n    const t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)\n    const t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)\n    const t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)\n    const t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)\n    const t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)\n    const t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)\n    const t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)\n    const t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)\n    const t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)\n    const t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)\n    const t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)\n    const t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)\n    const t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)\n    const t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)\n    const t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)\n    const t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)\n    const t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)\n    const t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)\n    const t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)\n    const t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)\n    const t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)\n    const t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)\n    const t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)\n    const t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)\n    const t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)\n    const t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)\n    const t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)\n    const t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)\n    const t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)\n    const t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)\n    const t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)\n    const t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)\n    const t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)\n    const t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)\n    const t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)\n    const t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)\n\n    // chi\n    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)\n    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)\n    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)\n    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)\n    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)\n    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)\n    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)\n    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)\n    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)\n    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)\n    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)\n    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)\n    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)\n    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)\n    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)\n    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)\n    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)\n    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)\n    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)\n    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)\n    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)\n    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)\n    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)\n    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)\n    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)\n    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)\n    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)\n    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)\n    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)\n    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)\n    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)\n    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)\n    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)\n    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)\n    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)\n    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)\n    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)\n    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)\n    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)\n    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)\n    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)\n    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)\n    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)\n    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)\n    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)\n    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)\n    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)\n    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)\n    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)\n    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)\n\n    // iota\n    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]\n    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]\n  }\n}\n","const keccakState = require('./keccak-state-unroll')\n\nfunction Keccak () {\n  // much faster than `new Array(50)`\n  this.state = [\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0\n  ]\n\n  this.blockSize = null\n  this.count = 0\n  this.squeezing = false\n}\n\nKeccak.prototype.initialize = function (rate, capacity) {\n  for (let i = 0; i < 50; ++i) this.state[i] = 0\n  this.blockSize = rate / 8\n  this.count = 0\n  this.squeezing = false\n}\n\nKeccak.prototype.absorb = function (data) {\n  for (let i = 0; i < data.length; ++i) {\n    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))\n    this.count += 1\n    if (this.count === this.blockSize) {\n      keccakState.p1600(this.state)\n      this.count = 0\n    }\n  }\n}\n\nKeccak.prototype.absorbLastFewBits = function (bits) {\n  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))\n  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)\n  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))\n  keccakState.p1600(this.state)\n  this.count = 0\n  this.squeezing = true\n}\n\nKeccak.prototype.squeeze = function (length) {\n  if (!this.squeezing) this.absorbLastFewBits(0x01)\n\n  const output = Buffer.alloc(length)\n  for (let i = 0; i < length; ++i) {\n    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff\n    this.count += 1\n    if (this.count === this.blockSize) {\n      keccakState.p1600(this.state)\n      this.count = 0\n    }\n  }\n\n  return output\n}\n\nKeccak.prototype.copy = function (dest) {\n  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]\n  dest.blockSize = this.blockSize\n  dest.count = this.count\n  dest.squeezing = this.squeezing\n}\n\nmodule.exports = Keccak\n","/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == 'http://www.w3.org/2000/svg') {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[] | null} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\t\tsubs = null;\n\t\t\t\t};\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tif (subs) {\n\t\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == null) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n","import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\n\t\t\t\twhile (oldDom && oldDom.nodeType === 8 && oldDom.nextSibling) {\n\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t}\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';\n\telse if (nodeType === 'math')\n\t\tnamespace = 'http://www.w3.org/1998/Math/MathML';\n\telse if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType === 'foreignObject'\n\t\t\t\t\t? 'http://www.w3.org/1999/xhtml'\n\t\t\t\t\t: namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType === 'progress' && inputValue == null) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != null) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? null\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n","import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["r","e","t","f","n","Array","isArray","length","clsx","arguments","module","exports","require","createKeccak","createShake","KeccakState","Keccak","Shake","algorithm","options","toLowerCase","Error","Transform","constructor","rate","capacity","delimitedSuffix","hashBitLength","super","this","_rate","_capacity","_delimitedSuffix","_hashBitLength","_options","_state","initialize","_finalized","_transform","chunk","encoding","callback","error","update","err","_flush","push","digest","data","Buffer","isBuffer","TypeError","from","absorb","absorbLastFewBits","squeeze","undefined","toString","_resetState","_clone","clone","copy","_read","size","dataByteLength","P1600_ROUND_CONSTANTS","p1600","s","round","lo0","hi0","lo1","hi1","lo2","hi2","lo3","hi3","lo4","hi4","lo","hi","t1slo0","t1shi0","t1slo5","t1shi5","t1slo10","t1shi10","t1slo15","t1shi15","t1slo20","t1shi20","t1slo1","t1shi1","t1slo6","t1shi6","t1slo11","t1shi11","t1slo16","t1shi16","t1slo21","t1shi21","t1slo2","t1shi2","t1slo7","t1shi7","t1slo12","t1shi12","t1slo17","t1shi17","t1slo22","t1shi22","t1slo3","t1shi3","t1slo8","t1shi8","t1slo13","t1shi13","t1slo18","t1shi18","t1slo23","t1shi23","t1slo4","t1shi4","t1slo9","t1shi9","t1slo14","t1shi14","t1slo19","t1shi19","t1slo24","t1shi24","t2slo0","t2shi0","t2slo16","t2shi16","t2slo7","t2shi7","t2slo23","t2shi23","t2slo14","t2shi14","t2slo10","t2shi10","t2slo1","t2shi1","t2slo17","t2shi17","t2slo8","t2shi8","t2slo24","t2shi24","t2slo20","t2shi20","t2slo11","t2shi11","t2slo2","t2shi2","t2slo18","t2shi18","t2slo9","t2shi9","t2slo5","t2shi5","t2slo21","t2shi21","t2slo12","t2shi12","t2slo3","t2shi3","t2slo19","t2shi19","t2slo15","t2shi15","t2slo6","t2shi6","t2slo22","t2shi22","t2slo13","t2shi13","t2slo4","t2shi4","keccakState","state","blockSize","count","squeezing","prototype","i","bits","output","alloc","dest","l","u","o","c","a","h","v","p","y","d","w","parentNode","removeChild","_","children","call","defaultProps","g","type","props","key","ref","__k","__","__b","__e","__d","__c","__v","__i","__u","vnode","m","current","b","k","context","x","C","base","M","P","__r","debounceRendering","sort","shift","__P","O","__n","namespaceURI","j","S","$","N","I","nextSibling","String","L","V","contains","insertBefore","nodeType","H","some","T","setProperty","test","A","style","cssText","replace","slice","addEventListener","removeEventListener","removeAttribute","setAttribute","F","event","render","contextType","value","__E","q","sub","__h","_sb","__s","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","indexOf","z","diffed","localName","document","createTextNode","createElementNS","is","__m","childNodes","attributes","name","__html","innerHTML","unmount","componentWillUnmount","B","firstChild","D","E","G","Consumer","Provider","splice","getDerivedStateFromError","setState","componentDidCatch","forceUpdate","Promise","then","bind","resolve","setTimeout","__H","__N","filter","every","forEach","concat","useDebugValue","requestAnimationFrame","clearTimeout","cancelAnimationFrame"],"sourceRoot":""}